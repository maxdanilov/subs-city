=begindesc 'posters update'task :update_posters => :environment do |task|	t = start_task(task)	Movie.all.each do |m|		# if poster doesn't exist, load it from kp, not kassa		if (not m.poster_exists?) and (not m.kinopoisk_id.nil?)			puts "Downloading kinopoisk poster for [#{m.movie_id}] #{m.title}"			Kinopoisk.download_poster(m, true) 		end	end	path = '../public/images/posters/'	max_width = 144	threshold_width = 150	threshold_size = 20000	Dir.foreach(path) do |file|		next if file == '.' or file == '..'		size = File::size(path + file)		img = Magick::Image::read(path + file)[0] rescue nil		puts "unable to open #{file}" if img.nil?		if img and (img.columns > threshold_width or size > threshold_size)			ratio = img.rows * 1.0 / img.columns			img = img.thumbnail(max_width, max_width * ratio)			img.write path + file			puts "thumbnailing #{file}"		end	end	stop_task(task, t)end=end=begindesc 'update movies posters cache'task :update_movies_posters => :environment do	t = Timer.new.start	poster_filename = -> (m) { "../public/images/posters/" + m.movie_id.to_s + ".jpg" }	puts "Starting the download of missing posters...".cyan	Movie.select([:movie_id, :poster]).each do |m|		next if File.exist?(poster_filename.call(m))		puts "\tDownloading #{m.poster}...".yellow		begin		   	open(m.poster) do |f|		   	File.open(poster_filename.call(m), "wb") do |file|		    	file.puts f.read		   	end			end		rescue		end	end	t.stop	puts "Task took #{t.get} seconds to run".cyanend=end=begindesc 'fill movies with info from Cinemate' task :update_movies_info => :environment do	t = Timer.new.start	Movie.where("cinemate_id IS NULL AND year IS NOT NULL").each do |c|		key = Cinemate.get_csrf_token		id = Cinemate.get_movie_id(Cinemate.prepare_title(Cinemate.prepare_title_for_search(c.title)), key, c.year)		unless id.nil?			results = Cinemate.get_and_parse_movie_page(id)			if Cinemate.equal_titles?(results[:title_russian], Cinemate.prepare_title_for_search(c.title))				c.title_original = results[:title_original]				c.director = results[:director]				c.cast = results[:cast]				c.description = results[:description]				c.kinopoisk_id = results[:kinopoisk_id]				c.imdb_id = results[:imdb_id]				c.cinemate_id = id				puts "Movie #{c.movie_id} was changed in the database:".yellow				puts c				c.save			end		else			puts "\tMovie #{c.movie_id} was not found on Cinemate".red			puts c		end	end	t.stop	puts "Task took #{t.get} seconds to run".cyanenddesc 'update kinopoisk buttons cache'task :update_kinopoisk_buttons => :environment do |task|	t = start_task(task)	filename = -> (m) { "../public/images/kinopoisk/" + m.kinopoisk_id.to_s + ".png" }	url = -> (m) { "http://rating.kinopoisk.ru/#{m.kinopoisk_id}.gif" }	puts "Starting update of all buttons...".cyan	total = Movie.active.count	Movie.active.select([:kinopoisk_id]).each_with_index do |m, index|		next if m.kinopoisk_id.nil? 		puts "\t[#{index+1}/#{total}] Downloading #{m.kinopoisk_id}...".yellow		begin		   	open(url.call(m)) do |f|		   	File.open(filename.call(m), "wb") do |file|		    	file.puts f.read		   	end			end		rescue		end		sleep rand(0.5..1.0)	end	stop_task(task, t)end=endtask :update_languages => :environment do |task|	t = start_task(task)	Movie.where('languages IS NULL').each do |m|		next if m.imdb_id.nil?		begin			movie = Imdb::Movie.new(m.imdb_id.to_s)			langs = movie.languages.join(", ")			puts " #{movie.title} [#{langs}]"			m.update_attribute(:languages, langs)		rescue			puts "Error occured for movie #{m.id}".red		end	end	stop_task(task, t)endtask :test_kinopoisk => :environment do |task|	k = KinopoiskParser::Movie.new 580180	puts k.actors.join(", ")end