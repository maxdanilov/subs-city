desc 'load all models and require modules for ActiveRecord'
task :init do
	#require 'padrino'
	gem 'activerecord', '<4'
	require 'active_record'
	require 'colorize'

	ROOT_PATH = '../'
	DB = ROOT_PATH + 'db/subscity_development.db'
	DIRS = [ROOT_PATH + 'app/helpers', ROOT_PATH + 'models']

	DIRS.each do |dir|
		Dir[File.join(File.dirname(__FILE__), dir, '*.rb')].each {|file| require file rescue nil}
	end

	ActiveRecord::Base::establish_connection( :adapter => 'sqlite3', :database => DB)
	I18n.enforce_available_locales = false
				
	puts "Init complete".green
end

desc 'update movies list'
task :update_movies => :init do
	t = Timer.new.start
	page_size = KassaFetcher::PAGE_SIZE
	
	updated_count = 0
	fetched_count = 0
	items_count = 0
	page_count = 0

	#mark all movies in the base as inactive
	Movie.all.each { |m| m.update_attribute(:active, false) }
	
	City.all.map(&:city_id).each do |city_id|

		items_count = 0
		page_count = 0

		loop do 
			parsed = KassaParser.parse_json(KassaFetcher.fetch_movies(page_count * page_size, page_size, city_id))
			
			items = parsed["Items"]
			
			items.each do |item|

				c = Movie.new(	movie_id: item["objectId"], 
								name: item["name"], 
								age_restriction: item["ageRestriction"], 
								country: item["country"], 
								year: item["productionYear"], 
								genres: item["visibleTagsString"], 
								thumbnail: Movie.upd_thumbnail(item["thumbnail"]), 
								active: true, 
								duration: item["duration"] )

				if c.in_db?
					#mark as active in db
					Movie.get_movie(c.movie_id).update_attribute(:active, true)
				else
					#add to db
					if c.valid?
						puts "Movie #{s.screening_id} was added to database:".yellow
						print "\t"
						p c

						c.save
						updated_count += 1
					end
				end
			end
			
			items_count += items.size
			fetched_count += items.size
			total_count ||= parsed["TotalCount"]
			
			page_count += 1
			
			break if items_count >= total_count
			sleep 1
		end
	end

	t.stop
	puts "#{fetched_count} movies fetched, #{updated_count} updated in the base".red
	puts "Task took #{t.get} seconds to run".cyan
end

desc 'fill movies with info from Cinemate' 
task :update_movies_info => :init do
end

desc 'update cinemas list' 
task :update_cinemas => :init do
	t = Timer.new.start
	page_size = KassaFetcher::PAGE_SIZE
	
	updated_count = 0
	fetched_count = 0
	items_count = 0
	page_count = 0
	
	City.all.map(&:city_id).each do |city_id|
		items_count = 0
		page_count = 0

		loop do 
			parsed = KassaParser.parse_json(KassaFetcher.fetch_cinemas(page_count * page_size, page_size, city_id))
			items = parsed["Items"]
			items.each do |item|
				c = Cinema.new(cinema_id: item["PlaceID"], city_id: city_id, name: item["Name"], address: item["Address"], metro: item["Metro"])
				if c.valid?
					puts "\tCinema #{s.cinema_id} was added to database:".yellow
					print "\t"
					p c

					c.save
					updated_count += 1
				end
			end
			
			items_count += items.size
			fetched_count += items.size
			total_count ||= parsed["TotalCount"]
			
			page_count += 1
			
			break if items_count >= total_count
			sleep 1
		end
	end

	t.stop
	puts "#{fetched_count} cinemas fetched, #{updated_count} updated in the base".red
	puts "Task took #{t.get} seconds to run".cyan
end

desc 'update screenings prices'
task :update_screenings_prices => :init do
	t = Timer.new.start
	fetched_count = Screening.active.no_prices.count
	updated_count = 0
	puts "Starting updating of #{fetched_count} screenings...".cyan
	Screening.active.no_prices.find_each do |s|
		max_price, min_price = KassaParser.parse_prices(KassaFetcher.fetch_prices(s.screening_id))
		if (!max_price.nil? and !min_price.nil?)
			s.price_min, s.price_max = min_price, max_price
			s.save
			updated_count += 1

			puts "\tScreening #{s.screening_id} was updated with prices [#{min_price}, #{max_price}]:".yellow
			puts s
		end
		sleep 0.5
	end

	t.stop
	puts "#{fetched_count} screenings processed, #{updated_count} updated in the base".red
	puts "Task took #{t.get} seconds to run".cyan
end

desc 'delete all obsolete screenings'
task :cleanup_screenings => :init do
	t = Timer.new.start

	deleted = 0
	puts "Starting cleanup of #{Screening.active.count} screenings...".cyan
	Screening.active.each do |s|
		unless s.exists?
			puts "\tScreening #{s.screening_id} was excluded from database:".yellow
			print "\t"
			p s

			deleted += 1
			s.destroy
		end
	end

	t.stop
	puts "#{deleted} screenings were deleted from database".red
	puts "Task took #{t.get} seconds to run".cyan
end

task :test => :init do
	
end
