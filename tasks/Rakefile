desc 'load all models and require modules for ActiveRecord'
task :environment do
	#require 'padrino'
	gem 'activerecord', '<4'
	require 'active_record'
	require 'imdb'
	require 'RMagick'
	require 'youtube_search'
	require 'htmlentities'
	#require 'active_support/core_ext'

	# no color output if script is run by cron
	if STDOUT.tty?
		require 'colorize'
	else
		class String
			def color
				self
			end

			[:black, :red, :green, :yellow, :blue, :magenta, :cyan, :white, :default, :light_black, :light_red, :light_green, :light_yellow, :light_blue, :light_magenta, :light_cyan, :light_white].each{|a| alias_method a, :color}
		end
	end

	require 'open-uri'
	require_relative './../db/.credentials'

	ROOT_PATH = '../'
	DIRS = [ROOT_PATH + 'app/helpers', ROOT_PATH + 'models']
	DIRS.each do |dir|
		Dir[File.join(File.dirname(__FILE__), dir, '*.rb')].each {|file| require file rescue nil}
	end

	require ROOT_PATH + "app/settings" rescue nil

	ActiveRecord::Base::establish_connection( :adapter => 'mysql2',
											  :encoding => 'utf8',
											  :reconnect => true,
											  :database => DB_NAME,
											  :pool => 50,
											  :wait_timeout => 1,
											  :username => DB_USER,
											  :password => DB_PASS,
											  :host => DB_HOST )

	I18n.enforce_available_locales = false
	puts "Init complete".green
end

def start_task(task)
	puts '-' * 80
	puts "[->][#{Time.now}] Starting task #{task.name}".cyan
	t = Timer.new.start
end

def stop_task(task, t)
	t.stop
	puts "[<-][#{Time.now}] Task #{task.name} took #{t.get} seconds to run".cyan
	puts '-' * 80
	puts
end

desc 'update screenings for all movies in the DB (active ones)'
task :update_screenings => :environment do |task, args|
	#do this before because cinemas can change movies assigned to screenings while keeping screening id!
	Rake::Task[:cleanup_screenings].reenable
	Rake::Task[:cleanup_screenings].invoke

	t = start_task(task)
	count_all = Movie.active.count
	Movie.active.each_with_index do |m, index|
		puts "\t[#{index + 1 } / #{count_all}] Processing movie...".yellow
		puts
		Rake::Task[:update_screenings_movie].invoke(m.movie_id)
		Rake::Task[:update_screenings_movie].reenable
		sleep rand(2..3)
	end

	Movie.all.each do |m|
		next if m.kinopoisk_id.to_i != 0 or m.has_description?
		next if m.screenings.count == 0
		puts "Auto filling info for (#{m.id}) [#{m.movie_id}] #{m.title}".green
		movie_auto_fill_info(m.id)
	end

	Rake::Task[:update_screenings_prices].reenable
	Rake::Task[:update_screenings_prices].invoke

	Rake::Task[:clear_cache].reenable
	Rake::Task[:clear_cache].invoke

	stop_task(task, t)
end

desc 'updates screenings for given movie (by id)'
task :update_screenings_movie, [:id] => :environment do |task, args|
	t = start_task(task)
	id = args[:id].to_i
	updated = 0	
	movie_not_in_base = Movie.where(:movie_id => id).first.nil?
	unless id == 0 or movie_not_in_base
		puts "Fetching screenings for movie: ".green
		m = Movie.where(:movie_id => id).first
		puts m
		# iterate through cities
		City.active.pluck(:city_id).each do |city_id|
			# first we parse all the available dates for given movie
			dates = KassaParser.parse_movie_dates(KassaFetcher.fetch_sessions(id, nil, city_id))
			# then iterate through them to fetch all sessions 
			dates.each_with_index do |date, index|
				#puts "Diff: #{difference_in_days(date, Time.now.strip)}"
				# if the movie has some screenings added, we can add new ones no matter how distant in the future they are
				if (m.get_screenings_all(city_id).count == 0 and difference_in_days(date, Time.now.strip) > SETTINGS[:screenings_fetch_span])				
					puts "-> [#{index + 1} / #{dates.size}] Skipping screenings for #{date}"
					next
				end
				puts "-> [#{index + 1} / #{dates.size}] Fetching screenings for #{date}".green
				KassaParser.parse_sessions_HTML(KassaFetcher.fetch_sessions(id, date, city_id), date, 0, id).each do |s|
					c = Screening.new(movie_id: id, cinema_id: s[:cinema], date_time: s[:time], screening_id: s[:session])
					if c.valid?
						next if (!c.movie.nil?) and c.movie.fetch_mode == FETCH_MODE[:movie][:subs] and (!c.has_subs?)
						c.save
						updated += 1

						puts "\tScreening #{c.screening_id} was added to the base: ".yellow
						puts c
					end
				end
			end
		end
	else
		puts "Movie with given ID (#{id}) not found.".red
	end

	puts "#{updated} screenings added to the base".red
	stop_task(task, t)
end

desc 'clean obsolete movies'
task :cleanup_movies => :environment do |task|
	t = start_task(task)
	# clear any movies (including active!) without Kinopoisk, IMDB, description info and screenings (their posters as well)
	count = 0
	Movie.where("kinopoisk_id IS NULL AND imdb_id IS NULL AND description IS NULL").each do |m|
		next if m.screenings.count > 0
		puts "removing [#{m.id}] #{m.title} (poster: #{m.poster_exists?})"	
		File.delete(m.poster_filename) if m.poster_exists?
		m.destroy
		count += 1
	end

	puts "#{count} movies removed"
	stop_task(task, t)
end

def get_movie(id)
	data = KassaParser.parse_movie_HTML(KassaFetcher.fetch_movie(id))
	m = nil
	begin
		m = Movie.new(	movie_id: id, 
					title: data[:title], 
					title_original: data[:title_original], 
					age_restriction: data[:age_restriction], 
					country: data[:country], 
					year: data[:year], 
					genres: data[:genres], 
					poster: data[:poster], 
					active: true, 
					duration: data[:duration] )
	rescue
	end
	m
end

desc 'update movies list'
task :update_movies => :environment do |task|
	t = start_task(task)
	page_size = KassaFetcher::PAGE_SIZE
	updated_count = 0
	fetched_count = 0
	items_count = 0
	page_count = 0

	#mark all movies in the base as inactive
	Movie.all.each { |m| m.update_attribute(:active, false) }
	
	City.active.pluck(:city_id).each do |city_id|

		items_count = 0
		page_count = 0

		loop do 
			parsed = KassaParser.parse_json(KassaFetcher.fetch_movies(page_count * page_size, page_size, city_id))
			items = parsed["Items"]
			items.each do |item|
				c = get_movie(item["objectId"])
				if c.nil?
					puts "Error occured fetching/parsing movie #{item["objectId"]}...".red
					next
				end
				
				# in case poster is changed
				#if c.in_db? and Movie.get_movie(c.movie_id).poster != c.poster and Movie.are_equal?(Movie.get_movie(c.movie_id), c)
				#	puts "poster for #{c.movie_id} has changed!".yellow
				#	#puts c
				#	KassaFetcher.download_poster(c, true) unless c.poster.nil?
				#	Movie.get_movie(c.movie_id).update_attribute(:poster, c.poster)
				#end

				if c.in_db? and Movie.are_equal?(Movie.get_movie(c.movie_id), c)
					#mark as active in db
					Movie.get_movie(c.movie_id).update_attribute(:active, true)
				else
					#movie name can be just changed!
					if c.in_db? and !Movie.are_equal?(Movie.get_movie(c.movie_id), c)
						#drop its' screenings
						puts "Movie's #{c.movie_id} screenings were destroyed due to movie title change".red
						Movie.get_movie(c.movie_id).screenings.destroy_all rescue nil
						#drop the old one
						Movie.get_movie(c.movie_id).destroy
						puts "Movie #{c.movie_id} was destroyed due to title change".red
					end
					#add to db
					if c.valid? and c.valid_genre? and (not c.russian?) and (not c.old?)
						#download poster
						KassaFetcher.download_poster(c, true) unless c.poster.nil?
						c.save
						puts "Movie #{c.movie_id} was added to database:".yellow
						puts c
						updated_count += 1
					end
				end
			end
			
			items_count += items.size
			fetched_count += items.size
			total_count ||= parsed["TotalCount"]
			
			page_count += 1
			
			break if items_count >= total_count
			sleep rand(1..1.5)
		end
	end

	puts "#{fetched_count} movies fetched, #{updated_count} updated in the base".red

	Rake::Task[:update_movies_from_cinemas].reenable
	Rake::Task[:update_movies_from_cinemas].invoke
	
	stop_task(task, t)
end

desc 'update movies from cinemas screenings'
task :update_movies_from_cinemas => :environment do |task|
	movies = []
	t = start_task(task)
	City.active.each do |city|
		total = city.get_cinemas.count
		city.get_cinemas.each_with_index do |cinema, index|
			puts "[#{index + 1} / #{total}] Processing cinema #{cinema.name} (#{city.name}) ...".magenta
			dates = KassaParser.parse_movie_dates(KassaFetcher.fetch_cinema(cinema.cinema_id, nil, city.city_id))
			dates.each do |date|
				screenings = KassaParser.parse_sessions_HTML(KassaFetcher.fetch_cinema(cinema.cinema_id, date, city.city_id), date, cinema.cinema_id)
				screenings.each { |s| movies += [s[:movie]] }
			end
			sleep rand(1..2)	
		end
	end
	movies = movies.compact.uniq.sort
	puts "All movies in cinemas:".green
	p movies

	puts "Movies that are not in base yet:".green
	movies_new = movies.find_all{ |m| Movie.get_movie(m) == nil }
	p movies_new

	# adding new movies to the base
	movies_new.each do |m|
		c = get_movie(m)

		if c.nil?
			puts "Error fetching movie #{item["objectId"]}...".red
			next
		end

		if c.valid? and c.valid_genre? and (not c.russian?) and (not c.old?)
			KassaFetcher.download_poster(c, true) unless c.poster.nil?
			c.save
			puts "Movie #{c.movie_id} was added to database:".yellow
			puts c
		else
			puts "Movie #{c.movie_id} was not added to database:".red
		end
	end

	# marking as active
	movies.each do |m|
		Movie.get_movie(m).update_attribute(:active, true) rescue nil
	end

	stop_task(task, t)
end

desc 'update cinemas list' 
task :update_cinemas => :environment do |task|
	t = start_task(task)
	page_size = KassaFetcher::PAGE_SIZE
	
	updated_count = 0
	fetched_count = 0
	items_count = 0
	page_count = 0
	
	City.active.pluck(:city_id).each do |city_id|
		items_count = 0
		page_count = 0

		loop do 
			parsed = KassaParser.parse_json(KassaFetcher.fetch_cinemas(page_count * page_size, page_size, city_id))
			items = parsed["Items"]
			items.each do |item|
				c = Cinema.new(cinema_id: item["PlaceID"], city_id: city_id, name: item["Name"], address: item["Address"], metro: item["Metro"])
				if c.valid?
					puts "\tCinema #{c.cinema_id} was added to database:".yellow
					print "\t"

					p c
					c.save
					updated_count += 1
				end
			end
			
			items_count += items.size
			fetched_count += items.size
			total_count ||= parsed["TotalCount"]
			
			page_count += 1
			
			break if items_count >= total_count
			sleep rand(1.0..2.0)
		end
	end

	puts "#{fetched_count} cinemas fetched, #{updated_count} updated in the base".red
	stop_task(task, t)
end

desc 'update movies ratings from kinopoisk data'
task :update_movie_ratings => :environment do |task|
	t = start_task(task)
	total = Movie.active.count
	Movie.active.each_with_index do |m, index|
		next if m.kinopoisk_id.nil? 
		puts "\t[#{index+1}/#{total}] Updating rating #{m.kinopoisk_id} [#{m.movie_id}][#{m.title}]...".yellow
		
		Kinopoisk.update_ratings(m)
		sleep rand(0.5..1)
	end

	Rake::Task[:clear_cache].reenable
	Rake::Task[:clear_cache].invoke

	stop_task(task, t)
end

desc 'update screenings prices'
task :update_screenings_prices => :environment do |task|
	t = start_task(task)
	screenings = Screening.active_all.no_prices
	fetched_count = screenings.count
	updated_count = 0
	puts "Starting updating of #{fetched_count} screenings...".cyan
	counter = 0
	screenings.find_each do |s|
		counter += 1

		if s.available?
			
			max_price, min_price = s.get_prices
			if (!max_price.nil? and !min_price.nil?)
				s.price_min, s.price_max = min_price, max_price
				s.save
				updated_count += 1

				puts "\t[#{counter}/#{fetched_count}] Screening #{s.screening_id} was updated with prices [#{min_price}, #{max_price}]:".yellow
			else
				puts "\t[#{counter}/#{fetched_count}] Screening #{s.screening_id} was not updated with prices".red
			end
				
		else
			puts "\t[#{counter}/#{fetched_count}] Screening #{s.screening_id} is not available".red
		end
		puts s
		sleep rand(0.5..1)
	end

	Rake::Task[:clear_cache].reenable
	Rake::Task[:clear_cache].invoke

	puts "#{fetched_count} screenings processed, #{updated_count} updated in the base".red
	stop_task(task, t)
end

desc 'seed cities table'
task :seed_cities => :environment do |task|
	City.new(:city_id => 2, :name => "Москва", :geoip => "Moscow; 48 RU", :domain => "msk", :active => true).save
	City.new(:city_id => 3, :name => "Санкт-Петербург", :geoip => "Saint Petersburg; 66 RU", :domain => "spb", :active => false).save
end

desc 'delete all obsolete screenings'
task :cleanup_screenings => :environment do |task|
	t = start_task(task)

	#clean old screenings
	old_screenings = Screening.before(Time.now.strip)
	puts "#{old_screenings.count} old screenings deleted".cyan
	old_screenings.destroy_all

	deleted = 0
	screenings = Screening.active_all
	puts "Starting cleanup of #{screenings.count} screenings...".cyan
	screenings.find_each do |s|
		if s.nil?
			"invalid screening: #{s.id}"
			next
		end

		if s.session_data.nil?
			puts "Error occured fetching session #{s.screening_id}".red
			next
		end

		if (!s.movie.nil?) and s.movie.fetch_mode == FETCH_MODE[:movie][:subs] and (!s.has_subs?)
			puts "Screening #{s.screening_id} was excluded from database cause it doesn't have subs:".yellow
			puts s
			deleted += 1
			s.destroy
			next
		end
		
		if (not s.exists?) or (not s.has_correct_title?) or (s.actual_date_time != s.date_time)
			puts "\tScreening #{s.screening_id} was excluded from database:".yellow
			puts s

			deleted += 1
			s.destroy
		end
	end

	Rake::Task[:clear_cache].reenable
	Rake::Task[:clear_cache].invoke

	puts "#{deleted} screenings were deleted from database".red
	stop_task(task, t)
end

def update_movie_trailer(id, video_id)
	id = id.to_i
	video_id = video_id.gsub('http://www.youtube.com/watch?v=','').gsub('youtube','').to_s
	unless id.zero?
		unless Movie.exists?(id)
			puts "Error: movie with id = #{id} wasn't found.".red
		else
			m = Movie.where(:id => id).first
			m.update_attribute(:trailer, video_id)
		end
	else
		puts "Error: movie id should be > 0".red
	end
end

desc 'update youtube trailer info'
task :update_movie_trailer, [:id, :video_id] => :environment do |task, args|
	t = start_task(task)
	update_movie_trailer(args[:id], args[:video_id])
	stop_task(task, t)
end

desc 'force update of all active movies with kinopoisk and imdb data'
task :update_movies_info => :environment do |task, args|
	t = start_task(task)
	Movie.active.each do |m|
		next if m.screenings.count == 0
		imdb_id = m.imdb_id.to_s
		kinopoisk_id = m.kinopoisk_id.to_s
		unless kinopoisk_id == 0
			Rake::Task[:update_movie_info].reenable
			Rake::Task[:update_movie_info].invoke(m.id.to_s, kinopoisk_id, imdb_id)
		end
	end
	Rake::Task[:clear_cache].reenable
	Rake::Task[:clear_cache].invoke
	Rake::Task[:fill_cache].invoke
	stop_task(task, t)
end

desc 'force update of given movie with kinopoisk data and trailer info'
task :update_movie_info, [:id, :kinopoisk_id, :imdb_id, :trailers] => :environment do |task, args|
	t = start_task(task)
	id = args[:id].to_i
	kinopoisk_id = args[:kinopoisk_id].to_i rescue 0
	imdb_id = args[:imdb_id].gsub(/\D/, '').to_i rescue 0
	trailers = args[:trailers].to_s

	puts "input data: id = #{id}, kinopoisk = #{kinopoisk_id}, imdb = #{imdb_id}, trailer = #{trailers}"

	unless id.zero? or kinopoisk_id.zero?
		unless Movie.exists?(id)
			puts "Error: movie with id = #{id} wasn't found.".red
		else
			m = Movie.where(:id => id).first
			puts m

			k = KinopoiskParser::Movie.new kinopoisk_id
			puts "Proposed kinopoisk title: #{k.title} [#{k.title_en}]".cyan 
			begin
				m.update_attribute(:kinopoisk_id, kinopoisk_id)
				m.update_attribute(:description, k.description) if (not k.description.to_s.empty?)# and (not m.description.to_s.empty?)
				m.update_attribute(:title_original, k.title_en) unless k.title_en.to_s.empty?
				m.update_attribute(:director, k.directors.join(", ")) unless k.directors.to_s.empty?
				m.update_attribute(:cast, k.actors.join(", ")) unless k.actors.to_s.empty?
				m.update_attribute(:year, k.year) if m.year.nil?
				m.update_attribute(:genres, k.genres.join(", ")) unless k.genres.to_a.empty?

				puts k.description

				unless imdb_id.zero?
					m.update_attribute(:imdb_id, imdb_id) 
					begin
						movie = Imdb::Movie.new(m.imdb_id.to_s)
						langs = movie.languages.reject { |x| x == "None"}.join(", ")
						puts "#{movie.title} [#{langs}] [#{movie.plot_summary}]"												
						m.update_attribute(:languages, langs)
						if m.title_original.to_s.empty? and !movie.title.empty?
							m.update_attribute(:title_original, movie.title)
						end

						#if m.description.to_s.empty? and !movie.plot_summary.empty?
						if !movie.plot_summary.empty?
							m.update_attribute(:description_english, movie.plot_summary)
						end

						if m.title_original.to_s.empty? and !movie.title.empty?
							m.update_attribute(:title_original, movie.title)
						end

					rescue
						puts "Error occured while fetching language for movie #{m.movie_id}".red
					end
				end

				if m.poster.nil? and !k.poster.nil? and !m.poster_exists?
					Kinopoisk.download_poster(m, true)
				end

				Kinopoisk.update_ratings(m) unless m.kinopoisk_id.nil? 

				puts "Updated movie looks like this:".green
				puts m

				update_movie_trailer(id, trailers) unless trailers.empty?
				puts "clearing cache..."
				clear_cache_no_fill
			rescue
				puts "An error occured while updating".red
			end
		end
	else
		puts "Error: Input parameters can't be zero: id = #{id}, kinopoisk_id = #{kinopoisk_id}".red
	end
	stop_task(task, t)
end

def clear_cache_no_fill
	FileCache.expire
end

desc 'clear file cache, no fill'
task :clear_cache_no_fill => :environment do |task|
	t = start_task(task)
    clear_cache_no_fill
    stop_task(task, t)
end

desc 'clear file cache and fill'
task :clear_cache => :environment do |task|
	t = start_task(task)
    clear_cache_no_fill
    Rake::Task[:fill_cache].reenable
    Rake::Task[:fill_cache].invoke
    stop_task(task, t)
end

desc 'fill file cache'
task :fill_cache => :environment do |task|
	t = start_task(task)
    pages = [
	    		"sitemap.xml", 
	    		"movies", 
	    		"", 
	    		"dates/#{format_date_url(date_for_screening(Time.now))}", 
	    		"dates/#{format_date_url(date_for_screening(Time.now + 1.day))}", 
	    		"movies.rss", 
	    		"screenings.rss", 
	    		"dates/today.rss", 
	    		"dates/tomorrow.rss",
	    		"dates/overmorrow.rss"
	    	]
    domains = City.active.pluck(:domain)

    domains.each do |d|
    	pages.each do |p|
    		url = "http://" + d + "." + domain_name + "/" + p
    		puts "Fetching #{url} ...".yellow
    		begin
    			open(url, 'r', :read_timeout => 5).read
    		rescue
    			puts "  Failed to fetch. Server is not running?".red
    		end
    	end
    end
    stop_task(task, t)
end

def movie_auto_fill_info(id)
	m = Movie.where(:id => id).first rescue nil
	return if m.nil? or m.kinopoisk_id.to_i != 0
	ids = movie_find_id(m.title)
	kinopoisk_id = ids[:kinopoisk]
	imdb_id = ids[:imdb]
	if kinopoisk_id.nil?
		return if m.title_original.nil? or m.title_original.strip.empty?
		ids = movie_find_id(m.title_original)
		kinopoisk_id = ids[:kinopoisk]
		imdb_id = ids[:imdb]
		return if kinopoisk_id.nil?
	end
	# fetch primary data
	Rake::Task[:update_movie_info].reenable
	Rake::Task[:update_movie_info].invoke(m.id.to_s, kinopoisk_id.to_s, imdb_id.to_s)
	# now we can try to update trailers
	m = Movie.where(:id => id).first rescue nil
	return if m.nil? or not m.trailer.to_s.empty?
	trailers = movie_find_trailers(m.title.to_s, m.title_original.to_s)
	m.update_attribute(:trailer, trailers) unless trailers.nil?
end

def movie_find_trailer(title, lang = :ru, year = nil)
	prepare_title = -> (t) { t.mb_chars.downcase.to_s.strip.gsub(/[:.–—-]/, "").gsub("  ", " ") }
	return nil if prepare_title.call(title).empty?
	max_duration = 240
	trailer_key = "trailer"
	trailer_key = "трейлер" if lang == :ru
	query = [title, year, trailer_key].join " "
	
	id = nil
	YoutubeSearch.search(query).first(10).each do |v|
		next if v["duration"].to_i > max_duration or not prepare_title.call(v["title"]).include? trailer_key or not prepare_title.call(v["title"]).include? prepare_title.call(title)
		id = v["video_id"]
		break
	end
	id
end

def movie_find_trailers(title_ru, title_en = nil, year = nil)
	title_en ||= title_ru
	ru = movie_find_trailer(title_ru, :ru, year) rescue nil
	en = movie_find_trailer(title_en, :en, year) rescue nil
	return nil if en.nil? and ru.nil?
	return ru if en.nil?
	return en if ru.nil?
	return "#{en}*#{ru}"
end

def movie_find_id(title, year = nil)

	query = [title, year].join " "
	prepare_title = -> (t) { t.mb_chars.downcase.to_s.strip.gsub(/[:.–—-]/, "").gsub("  ", " ") }
	compare_titles = -> (t1, t2) { prepare_title.call(t1) == prepare_title.call(t2) }
	begin
		m = KinopoiskParser::Movie.new query
		title_en = m.title_en rescue ""
		title_en = m.title if title_en.empty?
		kinopoiskID = m.id
		kinopoiskID = nil if not compare_titles.call(m.title, title) and not compare_titles.call(m.title_en, title)
		kinopoiskID = kinopoiskID.to_i unless kinopoiskID.nil?
	rescue
		kinopoiskID = nil
	end

	query = [title_en, year].join " "

	if kinopoiskID != nil
		begin
			imdbID = Imdb::Search.new(query).movies[0].id
			title_original = Imdb::Movie.new(imdbID).title
			imdbID nil if not compare_titles.call(title_original, title) and not compare_titles.call(title_original, title_en)
			imdbID = imdbID.to_i unless imdbID.nil?
		rescue
			imdbID = nil
		end
	else
		imdbID = nil
	end
	return {:kinopoisk => kinopoiskID, :imdb => imdbID}
end

task :test_parsers => :environment do |task|
	t = start_task(task)

	result = []
	[:test_kassa, :test_kinopoisk_imdb].each { |f| result << send(f) }

	unless result.include? false
		puts "[OK]".green unless result.include? false
	else
		puts "[!!]".red
	end

	stop_task(task, t)
end

desc 'run a DB backup script'
task :backup => :environment do |task|
        t = start_task(task)
        sh "../backupdb.sh"
        stop_task(task, t)
end

desc 'download missing posters for movies'
task :movies_download_posters => :environment do |task|
        t = start_task(task)
	Movie.all.each do |m|
		next if m.poster.nil?
		next if m.poster_exists?
		puts m.title + " " + m.poster
		m.download_poster(m.poster)
	end
        stop_task(task, t)
end

task :test => :environment do |task|
        t = start_task(task)
        stop_task(task, t)
end
