desc 'load all models and require modules for ActiveRecord'
task :environment do
	#require 'padrino'
	gem 'activerecord', '<4'
	require 'active_record'

	# no color output if script is run by cron
	if STDOUT.tty?
		require 'colorize'
	else
		class String
			def color
				self
			end

			[:black, :red, :green, :yellow, :blue, :magenta, :cyan, :white, :default, :light_black, :light_red, :light_green, :light_yellow, :light_blue, :light_magenta, :light_cyan, :light_white].each{|a| alias_method a, :color}
		end
	end

	require 'open-uri'

	ROOT_PATH = '../'
	DB = ROOT_PATH + 'db/subscity_development.db'
	DIRS = [ROOT_PATH + 'app/helpers', ROOT_PATH + 'models']
	DIRS.each do |dir|
		Dir[File.join(File.dirname(__FILE__), dir, '*.rb')].each {|file| require file rescue nil}
	end
	ActiveRecord::Base::establish_connection( :adapter => 'sqlite3', :database => DB)
	I18n.enforce_available_locales = false
	puts "Init complete".green
end

def start_task(task)
	puts '-' * 80
	puts "[->][#{Time.now}] Starting task #{task.name}".cyan
	t = Timer.new.start
end

def stop_task(task, t)
	t.stop
	puts "[<-][#{Time.now}] Task #{task.name} took #{t.get} seconds to run".cyan
	puts '-' * 80
	puts
end

desc 'update screenings for all movies in the DB (active ones)'
task :update_screenings => :environment do |task, args|
	t = start_task(task)
	count_all = Movie.active.count
	Movie.active.each_with_index do |m, index|
		puts "\t[#{index + 1 } / #{count_all}] Processing movie...".yellow
		puts
		Rake::Task[:update_screenings_movie].invoke(m.movie_id)
		Rake::Task[:update_screenings_movie].reenable
		sleep rand(2..3)
	end
	stop_task(task, t)
end

desc 'updates screenings for given movie (by id)'
task :update_screenings_movie, [:id] => :environment do |task, args|
	t = start_task(task)
	id = args[:id].to_i
	updated = 0	
	movie_not_in_base = Movie.where(:movie_id => id).first.nil?
	unless id == 0 or movie_not_in_base
		puts "Fetching screenings for movie: ".green
		puts Movie.where(:movie_id => id).first
		# iterate through cities
		City.pluck(:city_id).each do |city_id|
			# first we parse all the available dates for given movie
			dates = KassaParser.parse_movie_dates(KassaFetcher.fetch_sessions(id, nil, city_id))
			# then iterate through them to fetch all sessions 
			dates.each_with_index do |date, index|
				puts "-> [#{index + 1} / #{dates.size}] Fetching screenings for #{date}".green
				puts
				KassaParser.parse_sessions_HTML(KassaFetcher.fetch_sessions(id, date, city_id), date).each do |s|
					c = Screening.new(movie_id: id, cinema_id: s[:cinema], date_time: s[:time], screening_id: s[:session])
					if c.valid?
						c.save
						updated += 1

						puts "\tScreening #{c.screening_id} was added to the base: ".yellow
						puts c
					end
				end
			end
		end
	else
		puts "Movie with given ID (#{id}) not found.".red
	end

	puts "#{updated} screenings added to the base".red
	stop_task(task, t)
end

desc 'update movies list'
task :update_movies => :environment do
	t = Timer.new.start
	page_size = KassaFetcher::PAGE_SIZE
	poster_filename = -> (m) { "../public/images/posters/" + m.movie_id.to_s + ".jpg" }
	updated_count = 0
	fetched_count = 0
	items_count = 0
	page_count = 0

	#mark all movies in the base as inactive
	Movie.all.each { |m| m.update_attribute(:active, false) }
	
	#City.all.map(&:city_id).each do |city_id|
	City.pluck(:city_id).each do |city_id|

		items_count = 0
		page_count = 0

		loop do 
			parsed = KassaParser.parse_json(KassaFetcher.fetch_movies(page_count * page_size, page_size, city_id))
			items = parsed["Items"]
			items.each do |item|

				c = Movie.new(	movie_id: item["objectId"], 
								title: item["name"], 
								age_restriction: item["ageRestriction"], 
								country: item["country"], 
								year: item["productionYear"], 
								genres: item["visibleTagsString"], 
								poster: Movie.upd_thumbnail(item["thumbnail"]), 
								active: true, 
								duration: item["duration"] )

				if c.in_db?
					#mark as active in db
					Movie.get_movie(c.movie_id).update_attribute(:active, true)
				else
					#add to db
					if c.valid? and c.valid_genre?
						puts "Movie #{c.movie_id} was added to database:".yellow

						#fetch data from cinemate
						unless c.year.nil?
							key =  Cinemate.get_csrf_token
							#id = Cinemate.get_movie_id(c.title, key, c.year)
							id = Cinemate.get_movie_id(Cinemate.prepare_title(Cinemate.prepare_title_for_search(c.title)), key, c.year)
							unless id.nil?
								results = Cinemate.get_and_parse_movie_page(id)
								#if results[:title_russian] == c.title
								if Cinemate.equal_titles?(results[:title_russian], Cinemate.prepare_title_for_search(c.title))
									c.title_original = results[:title_original]
									c.director = results[:director]
									c.cast = results[:cast]
									c.description = results[:description]
									c.kinopoisk_id = results[:kinopoisk_id]
									c.imdb_id = results[:imdb_id]
									c.cinemate_id = id
								end
							else
								puts "\tMovie #{c.movie_id} was not found on Cinemate".red
							end
						end

						#download poster
						unless File.exist?(poster_filename.call(c))
							puts "\tDownloading #{c.poster}...".yellow
							begin
							   	open(c.poster) do |f|
							   	File.open(poster_filename.call(c), "wb") do |file|
							    	file.puts f.read
							   	end
								end
							rescue
								puts "\tError occured while loading poster".red
							end
						end

						puts c
						c.save
						updated_count += 1
					end
				end
			end
			
			items_count += items.size
			fetched_count += items.size
			total_count ||= parsed["TotalCount"]
			
			page_count += 1
			
			break if items_count >= total_count
			sleep rand(1..1.5)
		end
	end

	t.stop
	puts "#{fetched_count} movies fetched, #{updated_count} updated in the base".red
	puts "Task took #{t.get} seconds to run".cyan
end

=begin

desc 'fill movies with info from Cinemate' 
task :update_movies_info => :environment do
	t = Timer.new.start
	Movie.where("cinemate_id IS NULL AND year IS NOT NULL").each do |c|
		key = Cinemate.get_csrf_token
		id = Cinemate.get_movie_id(Cinemate.prepare_title(Cinemate.prepare_title_for_search(c.title)), key, c.year)
		unless id.nil?
			results = Cinemate.get_and_parse_movie_page(id)
			if Cinemate.equal_titles?(results[:title_russian], Cinemate.prepare_title_for_search(c.title))
				c.title_original = results[:title_original]
				c.director = results[:director]
				c.cast = results[:cast]
				c.description = results[:description]
				c.kinopoisk_id = results[:kinopoisk_id]
				c.imdb_id = results[:imdb_id]
				c.cinemate_id = id

				puts "Movie #{c.movie_id} was changed in the database:".yellow
				puts c
				c.save
			end
		else
			puts "\tMovie #{c.movie_id} was not found on Cinemate".red
			puts c
		end
	end
	t.stop
	puts "Task took #{t.get} seconds to run".cyan
end

=end

desc 'update cinemas list' 
task :update_cinemas => :environment do
	t = Timer.new.start
	page_size = KassaFetcher::PAGE_SIZE
	
	updated_count = 0
	fetched_count = 0
	items_count = 0
	page_count = 0
	
	City.all.map(&:city_id).each do |city_id|
		items_count = 0
		page_count = 0

		loop do 
			parsed = KassaParser.parse_json(KassaFetcher.fetch_cinemas(page_count * page_size, page_size, city_id))
			items = parsed["Items"]
			items.each do |item|
				c = Cinema.new(cinema_id: item["PlaceID"], city_id: city_id, name: item["Name"], address: item["Address"], metro: item["Metro"])
				if c.valid?
					puts "\tCinema #{c.cinema_id} was added to database:".yellow
					print "\t"

					p c
					c.save
					updated_count += 1
				end
			end
			
			items_count += items.size
			fetched_count += items.size
			total_count ||= parsed["TotalCount"]
			
			page_count += 1
			
			break if items_count >= total_count
			sleep rand(1.0..2.0)
		end
	end

	t.stop
	puts "#{fetched_count} cinemas fetched, #{updated_count} updated in the base".red
	puts "Task took #{t.get} seconds to run".cyan
end

=begin

desc 'update movies posters cache'
task :update_movies_posters => :environment do
	t = Timer.new.start
	poster_filename = -> (m) { "../public/images/posters/" + m.movie_id.to_s + ".jpg" }

	puts "Starting the download of missing posters...".cyan
	Movie.select([:movie_id, :poster]).each do |m|
		next if File.exist?(poster_filename.call(m))
		puts "\tDownloading #{m.poster}...".yellow
		begin
		   	open(m.poster) do |f|
		   	File.open(poster_filename.call(m), "wb") do |file|
		    	file.puts f.read
		   	end
			end
		rescue
		end
	end
	t.stop
	puts "Task took #{t.get} seconds to run".cyan
end

=end

desc 'update screenings prices'
task :update_screenings_prices => :environment do |task|
	t = start_task(task)
	fetched_count = Screening.active.no_prices.count
	updated_count = 0
	puts "Starting updating of #{fetched_count} screenings...".cyan
	counter = 0
	Screening.active.no_prices.find_each do |s|
		counter += 1

		if s.available?
			
			max_price, min_price = s.get_prices
			if (!max_price.nil? and !min_price.nil?)
				s.price_min, s.price_max = min_price, max_price
				s.save
				updated_count += 1

				puts "\t[#{counter}/#{fetched_count}] Screening #{s.screening_id} was updated with prices [#{min_price}, #{max_price}]:".yellow
			else
				puts "\t[#{counter}/#{fetched_count}] Screening #{s.screening_id} was not updated with prices".red
			end
				
		else
			puts "\t[#{counter}/#{fetched_count}] Screening #{s.screening_id} is not available".red
		end
		puts s
		sleep rand(0.5..1)
	end

	puts "#{fetched_count} screenings processed, #{updated_count} updated in the base".red
	stop_task(task, t)
end

desc 'seed cities table'
task :seed_cities => :environment do
	City.new(:city_id => 2, :name => "Москва").save
	#City.new(:city_id => 3, :name => "Санкт-Петербург").save
end

desc 'delete all obsolete screenings'
task :cleanup_screenings => :environment do
	t = start_task(task)

	#clean old screenings
	puts "#{Screening.before(Time.now.strip).count} old screenings deleted".cyan
	Screening.before(Time.now.strip).destroy_all

	deleted = 0
	puts "Starting cleanup of #{Screening.active.count} screenings...".cyan
	Screening.active.each do |s|
		unless s.exists?
			puts "\tScreening #{s.screening_id} was excluded from database:".yellow
			puts s

			deleted += 1
			s.destroy
		end
	end

	puts "#{deleted} screenings were deleted from database".red
	stop_task(task, t)
end

task :testtask => :environment do |task|
	t = start_task(task)
	puts "Output test! is TTY: #{STDOUT.tty?}".green
	#File.open("out.txt", 'a') {|f| f.write("#{Time.now}\n") }
	#Rake::Task[:test2].invoke(10)
	#puts KassaParser.parse_tickets_available?(KassaFetcher.fetch_availability(9857931))
	#puts KassaParser.parse_tickets_available?(KassaFetcher.fetch_availability(9857508))
	stop_task(task, t)
end

task :test2, [:id] => :environment do |task, args|
	t = start_task(task)
	puts "id from task2: #{args[:id]}"
	stop_task(task, t)
end