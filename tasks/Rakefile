desc 'load all models and require modules for ActiveRecord'
task :environment do
	#require 'padrino'
	gem 'activerecord', '<4'
	require 'active_record'
	require 'imdb'

	# no color output if script is run by cron
	if STDOUT.tty?
		require 'colorize'
	else
		class String
			def color
				self
			end

			[:black, :red, :green, :yellow, :blue, :magenta, :cyan, :white, :default, :light_black, :light_red, :light_green, :light_yellow, :light_blue, :light_magenta, :light_cyan, :light_white].each{|a| alias_method a, :color}
		end
	end

	require 'open-uri'
	require './../db/.credentials'

	ROOT_PATH = '../'
	DIRS = [ROOT_PATH + 'app/helpers', ROOT_PATH + 'models']
	DIRS.each do |dir|
		Dir[File.join(File.dirname(__FILE__), dir, '*.rb')].each {|file| require file rescue nil}
	end

	ActiveRecord::Base::establish_connection( :adapter => 'mysql2',
											  :encoding => 'utf8',
											  :reconnect => true,
											  :database => DB_NAME,
											  :pool => 50,
											  :wait_timeout => 1,
											  :username => DB_USER,
											  :password => DB_PASS,
											  :host => DB_HOST )

	I18n.enforce_available_locales = false
	puts "Init complete".green
end

def start_task(task)
	puts '-' * 80
	puts "[->][#{Time.now}] Starting task #{task.name}".cyan
	t = Timer.new.start
end

def stop_task(task, t)
	t.stop
	puts "[<-][#{Time.now}] Task #{task.name} took #{t.get} seconds to run".cyan
	puts '-' * 80
	puts
end

desc 'update screenings for all movies in the DB (active ones)'
task :update_screenings => :environment do |task, args|
	t = start_task(task)
	count_all = Movie.active.count
	Movie.active.each_with_index do |m, index|
		puts "\t[#{index + 1 } / #{count_all}] Processing movie...".yellow
		puts
		Rake::Task[:update_screenings_movie].invoke(m.movie_id)
		Rake::Task[:update_screenings_movie].reenable
		sleep rand(2..3)
	end

	Rake::Task[:cleanup_screenings].reenable
	Rake::Task[:cleanup_screenings].invoke

	Rake::Task[:update_screenings_prices].reenable
	Rake::Task[:update_screenings_prices].invoke

	Rake::Task[:clear_cache].reenable
	Rake::Task[:clear_cache].invoke

	stop_task(task, t)
end

desc 'updates screenings for given movie (by id)'
task :update_screenings_movie, [:id] => :environment do |task, args|
	t = start_task(task)
	id = args[:id].to_i
	updated = 0	
	movie_not_in_base = Movie.where(:movie_id => id).first.nil?
	unless id == 0 or movie_not_in_base
		puts "Fetching screenings for movie: ".green
		puts Movie.where(:movie_id => id).first
		# iterate through cities
		City.active.pluck(:city_id).each do |city_id|
			# first we parse all the available dates for given movie
			dates = KassaParser.parse_movie_dates(KassaFetcher.fetch_sessions(id, nil, city_id))
			# then iterate through them to fetch all sessions 
			dates.each_with_index do |date, index|
				puts "-> [#{index + 1} / #{dates.size}] Fetching screenings for #{date}".green
				puts
				KassaParser.parse_sessions_HTML(KassaFetcher.fetch_sessions(id, date, city_id), date).each do |s|
					c = Screening.new(movie_id: id, cinema_id: s[:cinema], date_time: s[:time], screening_id: s[:session])
					if c.valid?
						c.save
						updated += 1

						puts "\tScreening #{c.screening_id} was added to the base: ".yellow
						puts c
					end
				end
			end
		end
	else
		puts "Movie with given ID (#{id}) not found.".red
	end

	puts "#{updated} screenings added to the base".red
	stop_task(task, t)
end

desc 'update movies list'
task :update_movies => :environment do |task|
	t = start_task(task)
	page_size = KassaFetcher::PAGE_SIZE
	updated_count = 0
	fetched_count = 0
	items_count = 0
	page_count = 0

	#mark all movies in the base as inactive
	Movie.all.each { |m| m.update_attribute(:active, false) }
	
	City.active.pluck(:city_id).each do |city_id|

		items_count = 0
		page_count = 0

		loop do 
			parsed = KassaParser.parse_json(KassaFetcher.fetch_movies(page_count * page_size, page_size, city_id))
			items = parsed["Items"]
			items.each do |item|
				c = Movie.new(	movie_id: item["objectId"], 
								title: item["name"], 
								age_restriction: item["ageRestriction"], 
								country: item["country"], 
								year: item["productionYear"], 
								genres: item["visibleTagsString"], 
								poster: Movie.upd_thumbnail(item["thumbnail"]), 
								active: true, 
								duration: item["duration"] )
				
				c['country'] = nil if c['country'].to_s.strip == '-'
				c['genres'] = nil if c['genres'].to_s.strip.empty?

				# in case poster is changed
				if c.in_db? and Movie.get_movie(c.movie_id).poster != c.poster and Movie.are_equal?(Movie.get_movie(c.movie_id), c)
					puts "poster for #{c.movie_id} has changed!".yellow
					#puts c
					KassaFetcher.download_poster(c, true) unless c.poster.nil?
					Movie.get_movie(c.movie_id).update_attribute(:poster, c.poster)
				end

				if c.in_db? and Movie.are_equal?(Movie.get_movie(c.movie_id), c)
					#mark as active in db
					Movie.get_movie(c.movie_id).update_attribute(:active, true)
				else
					#movie name can be just changed!
					if c.in_db? and !Movie.are_equal?(Movie.get_movie(c.movie_id), c)
						#drop the old one
						Movie.get_movie(c.movie_id).destroy
						puts "Movie #{c.movie_id} was destroyed".red
					end
					#add to db
					if c.valid? and c.valid_genre?
						puts "Movie #{c.movie_id} was added to database:".yellow

						#fetch data from cinemate
						unless c.year.nil?
							key =  Cinemate.get_csrf_token
							#id = Cinemate.get_movie_id(c.title, key, c.year)
							id = Cinemate.get_movie_id(Cinemate.prepare_title(Cinemate.prepare_title_for_search(c.title)), key, c.year)
							unless id.nil?
								c, changed = Cinemate.fill_with_data(c, id)

								#update ratings
								Kinopoisk.update_ratings(c) unless c.kinopoisk_id.nil? 

							else
								puts "\tMovie #{c.movie_id} was not found on Cinemate".red
							end
						end

						#download poster
						unless c.poster.nil?
							KassaFetcher.download_poster(c, true)
						else
							Kinopoisk.download_poster(c) unless c.kinopoisk_id.nil?
						end

						unless c.imdb_id.nil?
							begin
								movie = Imdb::Movie.new(c.imdb_id.to_s)
								langs = movie.languages.join(", ")
								puts "#{movie.title} [#{langs}]"
								c.update_attribute(:languages, langs)
							rescue
								puts "Error occured while fetching language for movie #{c.movie_id}".red
							end
						end

						puts c
						c.save
						updated_count += 1
					end
				end
			end
			
			items_count += items.size
			fetched_count += items.size
			total_count ||= parsed["TotalCount"]
			
			page_count += 1
			
			break if items_count >= total_count
			sleep rand(1..1.5)
		end
	end

	puts "#{fetched_count} movies fetched, #{updated_count} updated in the base".red

	Rake::Task[:update_movies_from_cinemas].reenable
	Rake::Task[:update_movies_from_cinemas].invoke

	stop_task(task, t)
end

desc 'update movies from cinemas screenings'
task :update_movies_from_cinemas => :environment do |task|
	movies = []
	t = start_task(task)
	City.active.each do |city|
		total = city.get_cinemas.count
		city.get_cinemas.each_with_index do |cinema, index|
			puts "[#{index + 1} / #{total}] Processing cinema #{cinema.name} (#{city.name}) ...".magenta
			dates = KassaParser.parse_movie_dates(KassaFetcher.fetch_cinema(cinema.cinema_id, nil, city.city_id))
			dates.each do |date|
				screenings = KassaParser.parse_sessions_HTML(KassaFetcher.fetch_cinema(cinema.cinema_id, date, city.city_id), date)
				screenings.each { |s| movies += [s[:movie]] }
			end
			sleep rand(1..2)	
		end
	end
	movies = movies.compact.uniq.sort
	puts "All movies in cinemas:".green
	p movies

	puts "Movies that are not in base yet:".green
	movies_new = movies.find_all{ |m| Movie.get_movie(m) == nil }
	p movies_new

	# adding new movies to the base
	movies_new.each do |m|
		item = KassaParser.parse_movie_HTML(KassaFetcher.fetch_movie(m))
		c = Movie.new(	movie_id: m, 
						title: item[:title], 
						title_original: item[:title_original], 
						age_restriction: item[:age_restriction], 
						country: item[:country], 
						year: item[:year], 
						genres: item[:genres], 
						poster: item[:poster], 
						active: true, 
						duration: item[:duration] )

		c['country'] = nil if c['country'].to_s.strip == '-'
		c['genres'] = nil if c['genres'].to_s.strip.empty?

		if c.valid? and c.valid_genre?			
			#fetch data from cinemate
			unless c.year.nil?
				key =  Cinemate.get_csrf_token
				id = Cinemate.get_movie_id(Cinemate.prepare_title(Cinemate.prepare_title_for_search(c.title)), key, c.year)
				unless id.nil?
					c, changed = Cinemate.fill_with_data(c, id)

					#update ratings
					Kinopoisk.update_ratings(c) unless c.kinopoisk_id.nil? 
				end
			end

			unless c.poster.nil?
				KassaFetcher.download_poster(c, true)
			else
				Kinopoisk.download_poster(c)
			end

			unless c.imdb_id.nil?
				begin
					movie = Imdb::Movie.new(c.imdb_id.to_s)
					langs = movie.languages.join(", ")
					puts "#{movie.title} [#{langs}]"
					c.update_attribute(:languages, langs)
				rescue
					puts "Error occured while fetching language for movie #{c.movie_id}".red
				end
			end

			c.save
			puts "Movie #{c.movie_id} was added to database:".yellow
			puts c
		else
			puts "Movie #{c.movie_id} was not added to database:".red
		end
	end

	# marking as active
	movies.each do |m|
		Movie.get_movie(m).update_attribute(:active, true)
	end

	stop_task(task, t)
end

desc 'update cinemas list' 
task :update_cinemas => :environment do |task|
	t = start_task(task)
	page_size = KassaFetcher::PAGE_SIZE
	
	updated_count = 0
	fetched_count = 0
	items_count = 0
	page_count = 0
	
	City.active.pluck(:city_id).each do |city_id|
		items_count = 0
		page_count = 0

		loop do 
			parsed = KassaParser.parse_json(KassaFetcher.fetch_cinemas(page_count * page_size, page_size, city_id))
			items = parsed["Items"]
			items.each do |item|
				c = Cinema.new(cinema_id: item["PlaceID"], city_id: city_id, name: item["Name"], address: item["Address"], metro: item["Metro"])
				if c.valid?
					puts "\tCinema #{c.cinema_id} was added to database:".yellow
					print "\t"

					p c
					c.save
					updated_count += 1
				end
			end
			
			items_count += items.size
			fetched_count += items.size
			total_count ||= parsed["TotalCount"]
			
			page_count += 1
			
			break if items_count >= total_count
			sleep rand(1.0..2.0)
		end
	end

	puts "#{fetched_count} cinemas fetched, #{updated_count} updated in the base".red
	stop_task(task, t)
end

desc 'update movies ratings from kinopoisk data'
task :update_movie_ratings => :environment do |task|
	t = start_task(task)
	total = Movie.active.count
	Movie.active.each_with_index do |m, index|
		next if m.kinopoisk_id.nil? 
		puts "\t[#{index+1}/#{total}] Updating rating #{m.kinopoisk_id} [#{m.movie_id}][#{m.title}]...".yellow
		
		Kinopoisk.update_ratings(m)
		sleep rand(0.5..1)
	end

	Rake::Task[:clear_cache].reenable
	Rake::Task[:clear_cache].invoke

	stop_task(task, t)
end

desc 'update screenings prices'
task :update_screenings_prices => :environment do |task|
	t = start_task(task)
	fetched_count = Screening.active.no_prices.count
	updated_count = 0
	puts "Starting updating of #{fetched_count} screenings...".cyan
	counter = 0
	Screening.active.no_prices.find_each do |s|
		counter += 1

		if s.available?
			
			max_price, min_price = s.get_prices
			if (!max_price.nil? and !min_price.nil?)
				s.price_min, s.price_max = min_price, max_price
				s.save
				updated_count += 1

				puts "\t[#{counter}/#{fetched_count}] Screening #{s.screening_id} was updated with prices [#{min_price}, #{max_price}]:".yellow
			else
				puts "\t[#{counter}/#{fetched_count}] Screening #{s.screening_id} was not updated with prices".red
			end
				
		else
			puts "\t[#{counter}/#{fetched_count}] Screening #{s.screening_id} is not available".red
		end
		puts s
		sleep rand(0.5..1)
	end

	Rake::Task[:clear_cache].reenable
	Rake::Task[:clear_cache].invoke

	puts "#{fetched_count} screenings processed, #{updated_count} updated in the base".red
	stop_task(task, t)
end

desc 'seed cities table'
task :seed_cities => :environment do |task|
	City.new(:city_id => 2, :name => "Москва", :geoip => "Moscow; 48 RU", :domain => "msk", :active => true).save
	City.new(:city_id => 3, :name => "Санкт-Петербург", :geoip => "Saint Petersburg; 66 RU", :domain => "spb", :active => false).save
end

desc 'delete all obsolete screenings'
task :cleanup_screenings => :environment do |task|
	t = start_task(task)

	#clean old screenings
	puts "#{Screening.before(Time.now.strip).count} old screenings deleted".cyan
	Screening.before(Time.now.strip).destroy_all

	deleted = 0
	puts "Starting cleanup of #{Screening.active.count} screenings...".cyan
	Screening.active.each do |s|
		unless s.exists?
			puts "\tScreening #{s.screening_id} was excluded from database:".yellow
			puts s

			deleted += 1
			s.destroy
		end
	end

	Rake::Task[:clear_cache].reenable
	Rake::Task[:clear_cache].invoke

	puts "#{deleted} screenings were deleted from database".red
	stop_task(task, t)
end

desc 'force update of all active movies with kinopoisk data'
task :update_movies_kinopoisk => :environment do |task|
	t = start_task(task)
	total = Movie.active.where('kinopoisk_id IS NOT NULL').count
	Movie.active.where('kinopoisk_id IS NOT NULL').each_with_index do |m, index|
		puts "[#{index + 1} / #{total}] #{m.title} ..."
		k = KinopoiskParser::Movie.new m.kinopoisk_id
		begin
			m.update_attribute(:description, k.description)
			m.update_attribute(:title_original, k.title_en) unless k.title_en.to_s.empty?
			m.update_attribute(:director, k.directors.join(", "))
			m.update_attribute(:cast, k.actors.join(", "))
			m.update_attribute(:year, k.year) if m.year.nil?
		rescue
			puts "Error occured while fetching language for movie #{m.movie_id}".red
		end
		sleep rand(1..1.5)
	end
	Rake::Task[:clear_cache].invoke
	stop_task(task, t)
end

desc 'force update of given movie with kinopoisk data'
task :update_movie_kinopoisk, [:id, :kinopoisk_id, :imdb_id] => :environment do |task, args|
	t = start_task(task)
	id = args[:id].to_i
	kinopoisk_id = args[:kinopoisk_id].to_i rescue 0
	imdb_id = args[:imdb_id].gsub(/\D/, '').to_i rescue 0

	unless id.zero? or kinopoisk_id.zero?
		unless Movie.exists?(id)
			puts "Error: movie with id = #{id} wasn't found.".red
		else
			puts "Do you really want to change this movie info?".yellow
			m = Movie.where(:id => id).first
			puts m
			print "[y/n]:".green
			update_flag = false
			while true
				case STDIN.gets.strip.downcase
					when 'y', 'yes'
        				update_flag = true
        				break
      				when /\Ano?\Z/ #n or no
        				break 
				end
			end

			if update_flag
				k = KinopoiskParser::Movie.new kinopoisk_id
				puts "Proposed kinopoisk title: #{k.title} [#{k.title_en}]".cyan 
				begin
					m.update_attribute(:kinopoisk_id, kinopoisk_id)
					m.update_attribute(:description, k.description)
					m.update_attribute(:title_original, k.title_en)
					m.update_attribute(:director, k.directors.join(", "))
					m.update_attribute(:cast, k.actors.join(", "))
					m.update_attribute(:year, k.year) if m.year.nil?

					unless imdb_id.zero?
						m.update_attribute(:imdb_id, imdb_id) 
						begin
							movie = Imdb::Movie.new(m.imdb_id.to_s)
							langs = movie.languages.join(", ")
							puts "#{movie.title} [#{langs}]"
							m.update_attribute(:languages, langs)
						rescue
							puts "Error occured while fetching language for movie #{m.movie_id}".red
						end
					end

					if m.poster.nil? and !k.poster.nil?
						Kinopoisk.download_poster(m, force_rewrite = true)
					end

					Kinopoisk.update_ratings(m) unless m.kinopoisk_id.nil? 

					puts "Updated movie looks like this:".green
					puts m

					Rake::Task[:clear_cache].reenable
					Rake::Task[:clear_cache].invoke
				rescue
					puts "An error occured while updating".red
				end
			end
		end
	else
		puts "Error: Input parameters can't be zero: id = #{id}, kinopoisk_id = #{kinopoisk_id}".red
	end
	stop_task(task, t)
end

desc 'fill movies with info from Cinemate' 
task :update_movies_info => :environment do |task|
	t = Timer.new.start
	Movie.where("cinemate_id IS NULL AND year IS NOT NULL AND description IS NULL").each do |c|
		key = Cinemate.get_csrf_token
		id = Cinemate.get_movie_id(Cinemate.prepare_title(Cinemate.prepare_title_for_search(c.title)), key, c.year)
		unless id.nil?
			c, changed = Cinemate.fill_with_data(c, id)
			if changed
				puts "Movie #{c.movie_id} was changed in the database:".yellow
				puts c
				c.save
			end
		else
			puts "\tMovie #{c.movie_id} was not found on Cinemate".red
			puts c
		end
	end
	t.stop
	puts "Task took #{t.get} seconds to run".cyan
end

desc 'clear file cache'
task :clear_cache => :environment do |task|
	t = start_task(task)
    FileCache.expire
    Rake::Task[:fill_cache].reenable
    Rake::Task[:fill_cache].invoke
    stop_task(task, t)
end

desc 'fill file cache'
task :fill_cache => :environment do |task|
	t = start_task(task)
    pages = ["cinemas", "movies", "", "dates/#{format_date_url(Time.now)}", "dates/#{format_date_url(Time.now + 1.day)}"]
    domains = City.active.pluck(:domain)

    domains.each do |d|
    	pages.each do |p|
    		url = "http://" + d + "." + domain_name + "/" + p
    		puts "Fetching #{url} ...".yellow
    		begin
    			open(url, 'r', :read_timeout => 5).read
    		rescue
    			puts "  Failed to fetch. Server is not running?".red
    		end
    	end
    end
    stop_task(task, t)
end

task :testtask => :environment do |task|
	t = start_task(task)
	puts "Output test! is TTY: #{STDOUT.tty?}".green
	stop_task(task, t)
end