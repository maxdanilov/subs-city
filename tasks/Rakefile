desc 'load all models and require modules for ActiveRecord'
task :environment do
	#require 'padrino'
	gem 'activerecord', '<4'
	require 'active_record'
	require 'colorize'
	require 'open-uri'

	ROOT_PATH = '../'
	DB = ROOT_PATH + 'db/subscity_development.db'
	DIRS = [ROOT_PATH + 'app/helpers', ROOT_PATH + 'models']
	DIRS.each do |dir|
		Dir[File.join(File.dirname(__FILE__), dir, '*.rb')].each {|file| require file rescue nil}
	end
	ActiveRecord::Base::establish_connection( :adapter => 'sqlite3', :database => DB)
	I18n.enforce_available_locales = false
	puts "Init complete".green
end

desc 'update movies list'
task :update_movies => :environment do
	t = Timer.new.start
	page_size = KassaFetcher::PAGE_SIZE
	poster_filename = -> (m) { "../public/images/posters/" + m.movie_id.to_s + ".jpg" }
	updated_count = 0
	fetched_count = 0
	items_count = 0
	page_count = 0

	#mark all movies in the base as inactive
	Movie.all.each { |m| m.update_attribute(:active, false) }
	
	City.all.map(&:city_id).each do |city_id|

		items_count = 0
		page_count = 0

		loop do 
			parsed = KassaParser.parse_json(KassaFetcher.fetch_movies(page_count * page_size, page_size, city_id))
			items = parsed["Items"]
			items.each do |item|

				c = Movie.new(	movie_id: item["objectId"], 
								title: item["name"], 
								age_restriction: item["ageRestriction"], 
								country: item["country"], 
								year: item["productionYear"], 
								genres: item["visibleTagsString"], 
								poster: Movie.upd_thumbnail(item["thumbnail"]), 
								active: true, 
								duration: item["duration"] )

				if c.in_db?
					#mark as active in db
					Movie.get_movie(c.movie_id).update_attribute(:active, true)
				else
					#add to db
					if c.valid? and c.valid_genre?
						puts "Movie #{c.movie_id} was added to database:".yellow

						#fetch data from cinemate
						unless c.year.nil?
							key =  Cinemate.get_csrf_token
							#id = Cinemate.get_movie_id(c.title, key, c.year)
							id = Cinemate.get_movie_id(Cinemate.prepare_title(Cinemate.prepare_title_for_search(c.title)), key, c.year)
							unless id.nil?
								results = Cinemate.get_and_parse_movie_page(id)
								#if results[:title_russian] == c.title
								if Cinemate.equal_titles?(results[:title_russian], Cinemate.prepare_title_for_search(c.title))
									c.title_original = results[:title_original]
									c.director = results[:director]
									c.cast = results[:cast]
									c.description = results[:description]
									c.kinopoisk_id = results[:kinopoisk_id]
									c.imdb_id = results[:imdb_id]
									c.cinemate_id = id
								end
							else
								puts "\tMovie #{c.movie_id} was not found on Cinemate".red
							end
						end

						#download poster
						unless File.exist?(poster_filename.call(m))
							puts "\tDownloading #{c.poster}...".yellow
							begin
							   	open(c.poster) do |f|
							   	File.open(poster_filename.call(c), "wb") do |file|
							    	file.puts f.read
							   	end
								end
							rescue
								puts "\tError occured while loading poster".red
							end
						end

						puts c
						c.save
						updated_count += 1
					end
				end
			end
			
			items_count += items.size
			fetched_count += items.size
			total_count ||= parsed["TotalCount"]
			
			page_count += 1
			
			break if items_count >= total_count
			sleep 1
		end
	end

	t.stop
	puts "#{fetched_count} movies fetched, #{updated_count} updated in the base".red
	puts "Task took #{t.get} seconds to run".cyan
end

=begin
task :update_movies_clean => :environment do
	puts "Starting to clean movies list...".cyan
	Movie.all.each do |m| 
		unless m.valid_genre?
			m.destroy
			puts "Movie #{m.movie_id} was deleted from the database:".yellow
			puts m
		end
	end
	puts "Cleaning complete".cyan
end
=end

desc 'fill movies with info from Cinemate' 
task :update_movies_info => :environment do
	t = Timer.new.start
	Movie.where("cinemate_id IS NULL AND year IS NOT NULL").each do |c|
		key = Cinemate.get_csrf_token
		id = Cinemate.get_movie_id(Cinemate.prepare_title(Cinemate.prepare_title_for_search(c.title)), key, c.year)
		unless id.nil?
			results = Cinemate.get_and_parse_movie_page(id)
			if Cinemate.equal_titles?(results[:title_russian], Cinemate.prepare_title_for_search(c.title))
				c.title_original = results[:title_original]
				c.director = results[:director]
				c.cast = results[:cast]
				c.description = results[:description]
				c.kinopoisk_id = results[:kinopoisk_id]
				c.imdb_id = results[:imdb_id]
				c.cinemate_id = id

				puts "Movie #{c.movie_id} was changed in the database:".yellow
				puts c
				c.save
			#else
			# 	puts "Kassa: #{c.title}" 
			#	puts "Cinemate: #{results[:title_russian]}\n"
			end
		else
			puts "\tMovie #{c.movie_id} was not found on Cinemate".red
			puts c
		end
	end
	t.stop
	puts "Task took #{t.get} seconds to run".cyan
end

desc 'update cinemas list' 
task :update_cinemas => :environment do
	t = Timer.new.start
	page_size = KassaFetcher::PAGE_SIZE
	
	updated_count = 0
	fetched_count = 0
	items_count = 0
	page_count = 0
	
	City.all.map(&:city_id).each do |city_id|
		items_count = 0
		page_count = 0

		loop do 
			parsed = KassaParser.parse_json(KassaFetcher.fetch_cinemas(page_count * page_size, page_size, city_id))
			items = parsed["Items"]
			items.each do |item|
				c = Cinema.new(cinema_id: item["PlaceID"], city_id: city_id, name: item["Name"], address: item["Address"], metro: item["Metro"])
				if c.valid?
					puts "\tCinema #{s.cinema_id} was added to database:".yellow
					print "\t"

					p c
					c.save
					updated_count += 1
				end
			end
			
			items_count += items.size
			fetched_count += items.size
			total_count ||= parsed["TotalCount"]
			
			page_count += 1
			
			break if items_count >= total_count
			sleep 1
		end
	end

	t.stop
	puts "#{fetched_count} cinemas fetched, #{updated_count} updated in the base".red
	puts "Task took #{t.get} seconds to run".cyan
end

task :update_movies_posters => :environment do
	t = Timer.new.start
	poster_filename = -> (m) { "../public/images/posters/" + m.movie_id.to_s + ".jpg" }

	puts "Starting the download of missing posters...".cyan
	Movie.select([:movie_id, :poster]).each do |m|
		next if File.exist?(poster_filename.call(m))
		puts "\tDownloading #{m.poster}...".yellow
		begin
		   	open(m.poster) do |f|
		   	File.open(poster_filename.call(m), "wb") do |file|
		    	file.puts f.read
		   	end
			end
		rescue
		end
	end
	t.stop
	puts "Task took #{t.get} seconds to run".cyan
end

desc 'update screenings prices'
task :update_screenings_prices => :environment do
	t = Timer.new.start
	fetched_count = Screening.active.no_prices.count
	updated_count = 0
	puts "Starting updating of #{fetched_count} screenings...".cyan
	Screening.active.no_prices.find_each do |s|
		max_price, min_price = KassaParser.parse_prices(KassaFetcher.fetch_prices(s.screening_id))
		if (!max_price.nil? and !min_price.nil?)
			s.price_min, s.price_max = min_price, max_price
			s.save
			updated_count += 1

			puts "\tScreening #{s.screening_id} was updated with prices [#{min_price}, #{max_price}]:".yellow
			puts s
		end
		sleep 0.5
	end

	t.stop
	puts "#{fetched_count} screenings processed, #{updated_count} updated in the base".red
	puts "Task took #{t.get} seconds to run".cyan
end

desc 'seed cities table'
task :seed_cities => :environment do
	City.new(:city_id => 2, :name => "Москва").save
	#City.new(:city_id => 3, :name => "Санкт-Петербург").save
end

desc 'delete all obsolete screenings'
task :cleanup_screenings => :environment do
	t = Timer.new.start

	#clean old screenings
	puts "#{Screening.before(Date.today.to_time).count} old screenings deleted".cyan
	Screening.before(Date.today.to_time).destroy_all

	deleted = 0
	puts "Starting cleanup of #{Screening.active.count} screenings...".cyan
	Screening.active.each do |s|
		unless s.exists?
			puts "\tScreening #{s.screening_id} was excluded from database:".yellow
			puts s

			deleted += 1
			s.destroy
		end
	end

	t.stop
	puts "#{deleted} screenings were deleted from database".red
	puts "Task took #{t.get} seconds to run".cyan
end

task :testtask => :environment do
	#puts Screening.first
	#puts KassaParser.parse_prices(KassaFetcher.fetch_prices(9705247))
end
