desc 'load all models and require modules for ActiveRecord'
task :environment do
	#require 'padrino'
	gem 'activerecord', '<4'
	require 'active_record'

	# no color output if script is run by cron
	if STDOUT.tty?
		require 'colorize'
	else
		class String
			def color
				self
			end

			[:black, :red, :green, :yellow, :blue, :magenta, :cyan, :white, :default, :light_black, :light_red, :light_green, :light_yellow, :light_blue, :light_magenta, :light_cyan, :light_white].each{|a| alias_method a, :color}
		end
	end

	require 'open-uri'
	require './../db/.credentials'

	ROOT_PATH = '../'
	DIRS = [ROOT_PATH + 'app/helpers', ROOT_PATH + 'models']
	DIRS.each do |dir|
		Dir[File.join(File.dirname(__FILE__), dir, '*.rb')].each {|file| require file rescue nil}
	end

=begin
	DB = ROOT_PATH + 'db/subscity_development.db'
	TIMEOUT = 10000
	ActiveRecord::Base::establish_connection( 	:adapter => 'sqlite3', 
												:database => DB, 
												:timeout => TIMEOUT)
=end

	ActiveRecord::Base::establish_connection( :adapter => 'mysql2',
											  :encoding => 'utf8',
											  :reconnect => true,
											  :database => 'subscity',
											  :pool => 50,
											  :wait_timeout => 1,
											  :username => DB_USER,
											  :password => DB_PASS,
											  :host => 'localhost' )

	I18n.enforce_available_locales = false
	puts "Init complete".green
end

def start_task(task)
	puts '-' * 80
	puts "[->][#{Time.now}] Starting task #{task.name}".cyan
	t = Timer.new.start
end

def stop_task(task, t)
	t.stop
	puts "[<-][#{Time.now}] Task #{task.name} took #{t.get} seconds to run".cyan
	puts '-' * 80
	puts
end

desc 'update screenings for all movies in the DB (active ones)'
task :update_screenings => :environment do |task, args|
	t = start_task(task)
	count_all = Movie.active.count
	Movie.active.each_with_index do |m, index|
		puts "\t[#{index + 1 } / #{count_all}] Processing movie...".yellow
		puts
		Rake::Task[:update_screenings_movie].invoke(m.movie_id)
		Rake::Task[:update_screenings_movie].reenable
		sleep rand(2..3)
	end

	Rake::Task[:clear_cache].reenable
	Rake::Task[:clear_cache].invoke

	stop_task(task, t)
end

desc 'updates screenings for given movie (by id)'
task :update_screenings_movie, [:id] => :environment do |task, args|
	t = start_task(task)
	id = args[:id].to_i
	updated = 0	
	movie_not_in_base = Movie.where(:movie_id => id).first.nil?
	unless id == 0 or movie_not_in_base
		puts "Fetching screenings for movie: ".green
		puts Movie.where(:movie_id => id).first
		# iterate through cities
		City.active.pluck(:city_id).each do |city_id|
			# first we parse all the available dates for given movie
			dates = KassaParser.parse_movie_dates(KassaFetcher.fetch_sessions(id, nil, city_id))
			# then iterate through them to fetch all sessions 
			dates.each_with_index do |date, index|
				puts "-> [#{index + 1} / #{dates.size}] Fetching screenings for #{date}".green
				puts
				KassaParser.parse_sessions_HTML(KassaFetcher.fetch_sessions(id, date, city_id), date).each do |s|
					c = Screening.new(movie_id: id, cinema_id: s[:cinema], date_time: s[:time], screening_id: s[:session])
					if c.valid?
						c.save
						updated += 1

						puts "\tScreening #{c.screening_id} was added to the base: ".yellow
						puts c
					end
				end
			end
		end
	else
		puts "Movie with given ID (#{id}) not found.".red
	end

	puts "#{updated} screenings added to the base".red
	stop_task(task, t)
end

desc 'update movies list'
task :update_movies => :environment do |task|
	t = start_task(task)
	page_size = KassaFetcher::PAGE_SIZE
	poster_filename = -> (m) { "../public/images/posters/" + m.movie_id.to_s + ".jpg" }
	updated_count = 0
	fetched_count = 0
	items_count = 0
	page_count = 0

	#mark all movies in the base as inactive
	Movie.all.each { |m| m.update_attribute(:active, false) }
	
	City.active.pluck(:city_id).each do |city_id|

		items_count = 0
		page_count = 0

		loop do 
			parsed = KassaParser.parse_json(KassaFetcher.fetch_movies(page_count * page_size, page_size, city_id))
			items = parsed["Items"]
			items.each do |item|
				c = Movie.new(	movie_id: item["objectId"], 
								title: item["name"], 
								age_restriction: item["ageRestriction"], 
								country: item["country"], 
								year: item["productionYear"], 
								genres: item["visibleTagsString"], 
								poster: Movie.upd_thumbnail(item["thumbnail"]), 
								active: true, 
								duration: item["duration"] )
				
				c['country'] = nil if c['country'].to_s.strip == '-'
				c['genres'] = nil if c['genres'].to_s.strip.empty?

				if c.in_db? and Movie.are_equal?(Movie.get_movie(c.movie_id), c)
					#mark as active in db
					Movie.get_movie(c.movie_id).update_attribute(:active, true)
				else
					#movie name can be just changed!
					if c.in_db? and !Movie.are_equal?(Movie.get_movie(c.movie_id), c)
						#drop the old one
						Movie.get_movie(c.movie_id).destroy
						puts "Movie #{c.movie_id} was destroyed".red
					end
					#add to db
					if c.valid? and c.valid_genre?
						puts "Movie #{c.movie_id} was added to database:".yellow

						#fetch data from cinemate
						unless c.year.nil?
							key =  Cinemate.get_csrf_token
							#id = Cinemate.get_movie_id(c.title, key, c.year)
							id = Cinemate.get_movie_id(Cinemate.prepare_title(Cinemate.prepare_title_for_search(c.title)), key, c.year)
							unless id.nil?
								results = Cinemate.get_and_parse_movie_page(id)
								#if results[:title_russian] == c.title
								if Cinemate.equal_titles?(results[:title_russian], Cinemate.prepare_title_for_search(c.title))
									c.title_original = results[:title_original]
									c.director = results[:director]
									c.cast = results[:cast]
									c.description = results[:description]
									c.kinopoisk_id = results[:kinopoisk_id]
									c.imdb_id = results[:imdb_id]
									c.cinemate_id = id
								end

								#update ratings

								unless c.kinopoisk_id.nil? 
									puts "\tUpdating rating #{c.kinopoisk_id}...".yellow
									result = Kinopoisk.get_ratings(c.kinopoisk_id) rescue nil
									unless result.nil? or result[:error] == true
										r = nil
										if Rating.exists?(:movie_id => c.movie_id)
											puts "\t\t Updating a record...".magenta
											r = Rating.where(:movie_id => c.movie_id).first
										else
											puts "\t\t Creating a record...".magenta
											r = Rating.new(	:movie_id => c.movie_id)
										end
								
										r[:kinopoisk_rating] = result[:kinopoisk][:rating]
										r[:kinopoisk_votes] = result[:kinopoisk][:votes]
										r[:imdb_rating] = result[:imdb][:rating]
										r[:imdb_votes] = result[:imdb][:votes]
								
										r.save
										puts "\t\t Update result: #{result}...".green
									else
										puts "\t\t An error occured for #{c.kinopoisk_id}...".red
									end
								end

							else
								puts "\tMovie #{c.movie_id} was not found on Cinemate".red
							end
						end

						#download poster
						unless File.exist?(poster_filename.call(c))
							puts "\tDownloading #{c.poster}...".yellow
							begin
							   	open(c.poster) do |f|
							   	File.open(poster_filename.call(c), "wb") do |file|
							    	file.puts f.read
							   	end
								end
							rescue
								puts "\tError occured while loading poster".red
							end
						end

						puts c
						c.save
						updated_count += 1
					end
				end
			end
			
			items_count += items.size
			fetched_count += items.size
			total_count ||= parsed["TotalCount"]
			
			page_count += 1
			
			break if items_count >= total_count
			sleep rand(1..1.5)
		end
	end

	puts "#{fetched_count} movies fetched, #{updated_count} updated in the base".red
	stop_task(task, t)
end

desc 'update cinemas list' 
task :update_cinemas => :environment do |task|
	t = start_task(task)
	page_size = KassaFetcher::PAGE_SIZE
	
	updated_count = 0
	fetched_count = 0
	items_count = 0
	page_count = 0
	
	City.active.pluck(:city_id).each do |city_id|
		items_count = 0
		page_count = 0

		loop do 
			parsed = KassaParser.parse_json(KassaFetcher.fetch_cinemas(page_count * page_size, page_size, city_id))
			items = parsed["Items"]
			items.each do |item|
				c = Cinema.new(cinema_id: item["PlaceID"], city_id: city_id, name: item["Name"], address: item["Address"], metro: item["Metro"])
				if c.valid?
					puts "\tCinema #{c.cinema_id} was added to database:".yellow
					print "\t"

					p c
					c.save
					updated_count += 1
				end
			end
			
			items_count += items.size
			fetched_count += items.size
			total_count ||= parsed["TotalCount"]
			
			page_count += 1
			
			break if items_count >= total_count
			sleep rand(1.0..2.0)
		end
	end

	puts "#{fetched_count} cinemas fetched, #{updated_count} updated in the base".red
	stop_task(task, t)
end

desc 'update movies ratings from kinopoisk data'
task :update_movie_ratings => :environment do |task|
	t = start_task(task)
	total = Movie.active.count
	Movie.active.each_with_index do |m, index|
		next if m.kinopoisk_id.nil? 
		puts "\t[#{index+1}/#{total}] Updating rating #{m.kinopoisk_id} [#{m.movie_id}][#{m.title}]...".yellow
		result = Kinopoisk.get_ratings(m.kinopoisk_id) rescue nil
		unless result.nil? or result[:error] == true
			r = nil
			if Rating.exists?(:movie_id => m.movie_id)
				puts "\t\t Updating a record...".magenta
				r = Rating.where(:movie_id => m.movie_id).first
			else
				puts "\t\t Creating a record...".magenta
				r = Rating.new(	:movie_id => m.movie_id)
			end
	
			r[:kinopoisk_rating] = result[:kinopoisk][:rating]
			r[:kinopoisk_votes] = result[:kinopoisk][:votes]
			r[:imdb_rating] = result[:imdb][:rating]
			r[:imdb_votes] = result[:imdb][:votes]
	
			r.save
			puts "\t\t Update result: #{result}...".green
		else
			puts "\t\t An error occured for #{m.kinopoisk_id}...".red
		end
		sleep rand(0.5..1)
	end

	Rake::Task[:clear_cache].reenable
	Rake::Task[:clear_cache].invoke

	stop_task(task, t)
end

desc 'update kinopoisk buttons cache'
task :update_kinopoisk_buttons => :environment do |task|
	t = start_task(task)
	filename = -> (m) { "../public/images/kinopoisk/" + m.kinopoisk_id.to_s + ".png" }
	url = -> (m) { "http://rating.kinopoisk.ru/#{m.kinopoisk_id}.gif" }

	puts "Starting update of all buttons...".cyan
	total = Movie.active.count
	Movie.active.select([:kinopoisk_id]).each_with_index do |m, index|
		next if m.kinopoisk_id.nil? 
		puts "\t[#{index+1}/#{total}] Downloading #{m.kinopoisk_id}...".yellow
		begin
		   	open(url.call(m)) do |f|
		   	File.open(filename.call(m), "wb") do |file|
		    	file.puts f.read
		   	end
			end
		rescue
		end
		sleep rand(0.5..1.0)
	end
	stop_task(task, t)
end

desc 'update screenings prices'
task :update_screenings_prices => :environment do |task|
	t = start_task(task)
	fetched_count = Screening.active.no_prices.count
	updated_count = 0
	puts "Starting updating of #{fetched_count} screenings...".cyan
	counter = 0
	Screening.active.no_prices.find_each do |s|
		counter += 1

		if s.available?
			
			max_price, min_price = s.get_prices
			if (!max_price.nil? and !min_price.nil?)
				s.price_min, s.price_max = min_price, max_price
				s.save
				updated_count += 1

				puts "\t[#{counter}/#{fetched_count}] Screening #{s.screening_id} was updated with prices [#{min_price}, #{max_price}]:".yellow
			else
				puts "\t[#{counter}/#{fetched_count}] Screening #{s.screening_id} was not updated with prices".red
			end
				
		else
			puts "\t[#{counter}/#{fetched_count}] Screening #{s.screening_id} is not available".red
		end
		puts s
		sleep rand(0.5..1)
	end

	Rake::Task[:clear_cache].reenable
	Rake::Task[:clear_cache].invoke

	puts "#{fetched_count} screenings processed, #{updated_count} updated in the base".red
	stop_task(task, t)
end

desc 'seed cities table'
task :seed_cities => :environment do |task|
	#City.new(:city_id => 2, :name => "Москва").save
	City.new(:city_id => 2, :name => "Москва", :geoip => "Moscow; 48 RU", :domain => "msk", :active => true).save
	City.new(:city_id => 3, :name => "Санкт-Петербург", :geoip => "Saint Petersburg; 66 RU", :domain => "spb", :active => false).save
end

desc 'delete all obsolete screenings'
task :cleanup_screenings => :environment do |task|
	t = start_task(task)

	#clean old screenings
	puts "#{Screening.before(Time.now.strip).count} old screenings deleted".cyan
	Screening.before(Time.now.strip).destroy_all

	deleted = 0
	puts "Starting cleanup of #{Screening.active.count} screenings...".cyan
	Screening.active.each do |s|
		unless s.exists?
			puts "\tScreening #{s.screening_id} was excluded from database:".yellow
			puts s

			deleted += 1
			s.destroy
		end
	end

	Rake::Task[:clear_cache].reenable
	Rake::Task[:clear_cache].invoke

	puts "#{deleted} screenings were deleted from database".red
	stop_task(task, t)
end

desc 'fill movies with info from Cinemate' 
task :update_movies_info => :environment do |task|
	t = Timer.new.start
	Movie.where("cinemate_id IS NULL AND year IS NOT NULL").each do |c|
		key = Cinemate.get_csrf_token
		id = Cinemate.get_movie_id(Cinemate.prepare_title(Cinemate.prepare_title_for_search(c.title)), key, c.year)
		unless id.nil?
			results = Cinemate.get_and_parse_movie_page(id)
			if Cinemate.equal_titles?(results[:title_russian], Cinemate.prepare_title_for_search(c.title))
				c.title_original = results[:title_original]
				c.director = results[:director]
				c.cast = results[:cast]
				c.description = results[:description]
				c.kinopoisk_id = results[:kinopoisk_id]
				c.imdb_id = results[:imdb_id]
				c.cinemate_id = id

				puts "Movie #{c.movie_id} was changed in the database:".yellow
				puts c
				c.save
			end
		else
			puts "\tMovie #{c.movie_id} was not found on Cinemate".red
			puts c
		end
	end
	t.stop
	puts "Task took #{t.get} seconds to run".cyan
end

desc 'clear file cache'
task :clear_cache => :environment do |task|
	t = start_task(task)
    FileCache.expire
    Rake::Task[:fill_cache].reenable
    Rake::Task[:fill_cache].invoke
    stop_task(task, t)
end

desc 'fill file cache'
task :fill_cache => :environment do |task|
	t = start_task(task)
    pages = ["cinemas", "movies", ""]
    domains = City.active.pluck(:domain)

    domains.each do |d|
    	pages.each do |p|
    		url = "http://" + d + "." + domain_name + "/" + p
    		puts "Fetching #{url} ...".yellow
    		open(url).read
    	end
    end
    stop_task(task, t)
end

task :testtask => :environment do |task|
	t = start_task(task)
	puts "Output test! is TTY: #{STDOUT.tty?}".green
	stop_task(task, t)
end
